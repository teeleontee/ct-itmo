-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/githubuser/hw4#readme</a>
@package hw4
@version 0.1.0.0


-- | This module contains the types from hw3 that are also needed for hw4.
module HW4.Types
data Annotated e a
(:#) :: a -> e -> Annotated e a
data Except e a
Error :: e -> Except e a
Success :: a -> Except e a
data Expr
Val :: Double -> Expr
Op :: Prim Expr -> Expr
data Prim a
Add :: a -> a -> Prim a
Sub :: a -> a -> Prim a
Mul :: a -> a -> Prim a
Div :: a -> a -> Prim a
Abs :: a -> Prim a
Sgn :: a -> Prim a
newtype State s a
S :: (s -> Annotated s a) -> State s a
[runS] :: State s a -> s -> Annotated s a
instance (GHC.Classes.Eq e, GHC.Classes.Eq a) => GHC.Classes.Eq (HW4.Types.Except e a)
instance (GHC.Show.Show e, GHC.Show.Show a) => GHC.Show.Show (HW4.Types.Except e a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq e) => GHC.Classes.Eq (HW4.Types.Annotated e a)
instance (GHC.Show.Show a, GHC.Show.Show e) => GHC.Show.Show (HW4.Types.Annotated e a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (HW4.Types.Prim a)
instance GHC.Show.Show a => GHC.Show.Show (HW4.Types.Prim a)
instance GHC.Classes.Eq HW4.Types.Expr
instance GHC.Show.Show HW4.Types.Expr
instance GHC.Num.Num HW4.Types.Expr
instance GHC.Real.Fractional HW4.Types.Expr

module HW4.T1
data EvaluationError
DivideByZero :: EvaluationError

-- | A State Monad that supports error handling
newtype ExceptState e s a
ES :: (s -> Except e (Annotated s a)) -> ExceptState e s a
[runES] :: ExceptState e s a -> s -> Except e (Annotated s a)

-- | basically <a>fmap</a> for <a>ExceptState</a>
mapExceptState :: (a -> b) -> ExceptState e s a -> ExceptState e s b

-- | Wraps a in a <a>ExceptState</a> monad
wrapExceptState :: a -> ExceptState e s a

-- | Joins <a>ExceptState</a>'s into one
joinExceptState :: ExceptState e s (ExceptState e s a) -> ExceptState e s a

-- | Modifies the State of <tt>ExceptsState</tt> by taking in a function `s
--   -&gt; s`
modifyExceptState :: (s -> s) -> ExceptState e s ()

-- | Throws Error no matter what
throwExceptState :: e -> ExceptState e s a

-- | Evaluates Expression and stores the state trace, if an expression
--   contrains division by zero - throws error
eval :: Expr -> ExceptState EvaluationError [Prim Double] Double
instance GHC.Classes.Eq HW4.T1.EvaluationError
instance GHC.Show.Show HW4.T1.EvaluationError
instance GHC.Base.Functor (HW4.T1.ExceptState e s)
instance GHC.Base.Applicative (HW4.T1.ExceptState e s)
instance GHC.Base.Monad (HW4.T1.ExceptState e s)

module HW4.T2

-- | throws in the Parser Monad
newtype ParseError
ErrorAtPos :: Natural -> ParseError

-- | Runs a computation of the parser
runP :: Parser a -> String -> Except ParseError a

-- | Consumes a single char from the string returns an Error if unable.
pChar :: Parser Char

-- | Throws in the parser monad
parseError :: Parser a

-- | The point of entry for our parser of arithmetic expressions.
--   
--   We are parsing the following CFG that is LL(1); The following are the
--   production rules for the grammar
--   
--   <ul>
--   <li>S -&gt; E</li>
--   <li>E -&gt; T E'</li>
--   <li>E' -&gt; + T E' | - T E' | eps</li>
--   <li>T -&gt; F T'</li>
--   <li>T' -&gt; * F T' | / F T' | eps</li>
--   <li>F -&gt; double | ( E )</li>
--   </ul>
--   
--   Examples of use are given below
--   
--   <pre>
--   &gt;&gt;&gt; parseExpr "3.14 + 1.618 * 2"
--   Success (Op (Add (Val 3.14) (Op (Mul (Val 1.618) (Val 2.0)))))
--   </pre>
--   
--   Can throw an Error if given unexpected input
--   
--   <pre>
--   &gt;&gt;&gt; parseExpr "24 + Hello"
--   Error (ErrorAtPos 3)
--   </pre>
parseExpr :: String -> Except ParseError Expr
instance GHC.Classes.Eq HW4.T2.ParseError
instance GHC.Show.Show HW4.T2.ParseError
instance GHC.Base.Monad HW4.T2.Parser
instance GHC.Base.Applicative HW4.T2.Parser
instance GHC.Base.Functor HW4.T2.Parser
instance GHC.Base.Alternative HW4.T2.Parser
instance GHC.Base.MonadPlus HW4.T2.Parser
