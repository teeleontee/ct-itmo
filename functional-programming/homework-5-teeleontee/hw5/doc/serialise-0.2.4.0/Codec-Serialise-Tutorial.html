<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Codec.Serialise.Tutorial</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">serialise-0.2.4.0: A binary serialisation library for Haskell values.</span><ul class="links" id="page-menu"><li><a href="src/Codec.Serialise.Tutorial.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Duncan Coutts 2015-2017</td></tr><tr><th>License</th><td>BSD3-style (see LICENSE.txt)</td></tr><tr><th>Maintainer</th><td>duncan@community.haskell.org</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>non-portable (GHC extensions)</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Codec.Serialise.Tutorial</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Introduction</a><ul><li><a href="#g:2">The CBOR format</a></li></ul></li><li><a href="#g:3">The <code>Serialise</code> class</a><ul><li><a href="#g:4">Encoding terms</a></li><li><a href="#g:5">Decoding terms</a></li></ul></li><li><a href="#g:6">Migrations</a></li><li><a href="#g:7">Working with foreign encodings</a><ul><li><a href="#g:8">Working with arbitrary terms</a></li><li><a href="#g:9">Examining encodings</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p><code>cborg</code> is a library for the serialisation of Haskell values.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Introduction</h1></a><div class="doc"><p>As in modern serialisation libraries, <code>cborg</code> offers
instance derivation via GHC's <code><a href="GHC.html#v:Generic" title="GHC">Generic</a></code> mechanism,</p><pre>import Codec.Serialise
import qualified Data.ByteString.Lazy as BSL

data Animal = HoppingAnimal { animalName :: String, hoppingHeight :: Int }
            | WalkingAnimal { animalName :: String, walkingSpeed :: Int }
            deriving (Generic)

instance Serialise Animal

fredTheFrog :: Animal
fredTheFrog = HoppingAnimal &quot;Fred&quot; 4

main = BSL.writeFile &quot;hi&quot; (serialise fredTheFrog)</pre><p>We can then later read Fred,</p><pre>main = do
    fred &lt;- deserialise &lt;$&gt; BSL.readFile &quot;hi&quot;
    print fred</pre></div><a href="#g:2" id="g:2"><h2>The CBOR format</h2></a><div class="doc"><p><code>cborg</code> uses the Concise Binary Object Representation, CBOR
(IETF RFC 7049, <a href="https://tools.ietf.org/html/rfc7049">https://tools.ietf.org/html/rfc7049</a>), as its serialised
representation. This encoding is efficient in both encoding/decoding complexity
as well as space, and is generally machine-independent.</p><p>The CBOR data model resembles that of JSON, having arrays, key/value maps,
integers, floating point numbers, binary strings, and text. In addition,
CBOR allows items to be <em>tagged</em> with a number which describes the type of data
that follows. This can be used both to identify which data constructor of a type
an encoding represents, as well as representing different versions of the same
constructor.</p><h3>A note on interoperability</h3><p><code>cborg</code> is intended primarily as a <em>serialisation</em> library for
Haskell values. That is, a means of stably storing Haskell values for later
reading by <code>cborg</code>. While it uses the CBOR encoding format, the
library is <em>not</em> primarily aimed to facilitate serialisation and
deserialisation across different CBOR implementations.</p><p>If you want to use <code>cborg</code> to serialise/deserialise values
for/from another CBOR implementation (either in Haskell or another language),
you should keep a few things in mind,</p><ol><li>The <code><a href="Codec-Serialise-Class.html#t:Serialise" title="Codec.Serialise.Class">Serialise</a></code> instances for some &quot;basic&quot; Haskell types (e.g. <code><a href="../base-4.14.3.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code>,
   <code><a href="../bytestring-0.10.12.0/Data-ByteString.html#v:ByteString" title="Data.ByteString">ByteString</a></code>, tuples) don't carry a tag, in contrast to common
   convention. This is an intentional design decision to minimize encoding size
   for types which are primitive enough that their representation can be
   considered stable.</li><li>The library reserves the right to change encodings in
   non-backwards-compatible ways across super-major versions. For example the
   library may start producing a new representation for some type. The new
   version of the library will be able to decode the old and new representation,
   but your different CBOR decoder would not be expecting the new representation
   and would have to be updated to match.</li><li>While the library tries to use standard encodings in its instances wherever possible,
   these instances aren't guaranteed to implement all valid variants of the
   encodings in the specification. For instance, the <code>UTCTime</code> instance only
   implements a small subset of the encodings described by the Extended Date
   RFC.</li></ol></div><a href="#g:3" id="g:3"><h1>The <code>Serialise</code> class</h1></a><div class="doc"><p><code>cborg</code> provides a <code><a href="Codec-Serialise-Class.html#t:Serialise" title="Codec.Serialise.Class">Serialise</a></code> class for convenient access to serialisers and
deserialisers. Writing a serialiser can be as simple as deriving <code>Generic</code> and
<code><a href="Codec-Serialise-Class.html#t:Serialise" title="Codec.Serialise.Class">Serialise</a></code>,</p><pre>-- with DerivingStrategies (GHC 8.2 and newer)
data Animal = ...
            deriving stock (Generic)
            deriving anyclass (Serialise)

-- older GHCs
data MyType = ...
            deriving (Generic)
instance Serialise MyType</pre><p>Of course, you can also write the equivalent serialisers manually.
A hand-rolled <code><a href="Codec-Serialise-Class.html#t:Serialise" title="Codec.Serialise.Class">Serialise</a></code> instance may be desireable for a variety
of reasons,</p><ul><li>Deviating from the type-guided encoding that the <code>Generic</code> instance will
   provide</li><li>Interfacing with other CBOR implementations</li><li>Enabling migrations for future changes to the type or its encoding</li></ul><p>A minimal hand-rolled instance will define the <code><a href="Codec-Serialise-Class.html#v:encode" title="Codec.Serialise.Class">encode</a></code> and <code><a href="Codec-Serialise-Class.html#v:decode" title="Codec.Serialise.Class">decode</a></code> methods,</p><pre>instance Serialise Animal where
    encode = encodeAnimal
    decode = decodeAnimal</pre><p>Below we will describe how to write these pieces.</p></div><a href="#g:4" id="g:4"><h2>Encoding terms</h2></a><div class="doc"><p>For the purposes of encoding, abstract CBOR representations are embodied by the
<code><a href="../cborg-0.2.6.0/Codec-CBOR-Encoding.html#v:Tokens" title="Codec.CBOR.Encoding">Tokens</a></code> type. Such a representation can be efficiently
built using the <code><a href="../cborg-0.2.6.0/Codec-CBOR-Encoding.html#v:Encoding" title="Codec.CBOR.Encoding">Encoding</a></code> <code><a href="../base-4.14.3.0/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a></code>.</p><p>For instance, to implement an encoder for the <code>Animal</code> type above we might write,</p><pre>encodeAnimal :: Animal -&gt; Encoding
encodeAnimal (HoppingAnimal name height) =
    encodeListLen 3 &lt;&gt; encodeWord 0 &lt;&gt; encode name &lt;&gt; encode height
encodeAnimal (WalkingAnimal name speed) =
    encodeListLen 3 &lt;&gt; encodeWord 1 &lt;&gt; encode name &lt;&gt; encode speed</pre><p>Here we see that each encoding begins with a <em>length</em>, describing how many
values belonging to our <code>Animal</code> will follow. We then encode a <em>tag</em>, which
identifies which constructor. We then encode the fields using their respective
<code><a href="Codec-Serialise-Class.html#t:Serialise" title="Codec.Serialise.Class">Serialise</a></code> instance.</p><p>It is recommended that you not deviate from this encoding scheme, including both
the length and tag, to ensure that you have the option to migrate your types
later on.</p><p>Also note that the recommended encoding represents Haskell constructor indexes
as CBOR words, not CBOR tags.</p></div><a href="#g:5" id="g:5"><h2>Decoding terms</h2></a><div class="doc"><p>Decoding CBOR representations to Haskell values is done in the <code><a href="Codec-Serialise-Decoding.html#t:Decoder" title="Codec.Serialise.Decoding">Decoder</a></code>
<code><a href="../base-4.14.3.0/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code>. We can write a <code><a href="Codec-Serialise-Decoding.html#t:Decoder" title="Codec.Serialise.Decoding">Decoder</a></code> for the <code>Animal</code> type defined above as
follows,</p><pre>decodeAnimal :: Decoder s Animal
decodeAnimal = do
    len &lt;- decodeListLen
    tag &lt;- decodeWord
    case (len, tag) of
      (3, 0) -&gt; HoppingAnimal &lt;$&gt; decode &lt;*&gt; decode
      (3, 1) -&gt; WalkingAnimal &lt;$&gt; decode &lt;*&gt; decode
      _      -&gt; fail &quot;invalid Animal encoding&quot;</pre></div><a href="#g:6" id="g:6"><h1>Migrations</h1></a><div class="doc"><p>One eventuality that data serialisation schemes need to account for is the need
for changes in the data's structure. There are two types of compatibility
which we might want to strive for in our serialisers,</p><ul><li>Backward compatibility, such that newer versions of the serialiser can read
   older versions of an encoding</li><li>Forward compatibility, such that older versions of the serialiser can read
   (or at least tolerate) newer versions of an encoding</li></ul><p>Below we will look at a few of the types of changes which we may need to make
and describe how these can be handled in a backwards-compatible manner with
<code>cborg</code>.</p><h3>Adding a constructor</h3><p>Say we want to add a new constructor to our <code>Animal</code> type, <code>SwimmingAnimal</code>,</p><pre>data Animal = HoppingAnimal { animalName :: String, hoppingHeight :: Int }
            | WalkingAnimal { animalName :: String, walkingSpeed :: Int }
            | SwimmingAnimal { numberOfFins :: Int }
            deriving (Generic)</pre><p>We can account for this in our hand-rolled serialiser by simply adding a new tag
to our encoder and decoder,</p><pre>encodeAnimal :: Animal -&gt; Encoding
-- HoppingAnimal, SwimmingAnimal cases are unchanged...
encodeAnimal (HoppingAnimal name height) =
    encodeListLen 3 &lt;&gt; encodeWord 0 &lt;&gt; encode name &lt;&gt; encode height
encodeAnimal (WalkingAnimal name speed) =
    encodeListLen 3 &lt;&gt; encodeWord 1 &lt;&gt; encode name &lt;&gt; encode speed
-- Here is out new case...
encodeAnimal (SwimmingAnimal numberOfFins) =
    encodeListLen 2 &lt;&gt; encodeWord 2 &lt;&gt; encode numberOfFins

decodeAnimal :: Decoder s Animal
decodeAnimal = do
    len &lt;- decodeListLen
    tag &lt;- decodeWord
    case (len, tag) of
      -- these cases are unchanged...
      (3, 0) -&gt; HoppingAnimal &lt;$&gt; decode &lt;*&gt; decode
      (3, 1) -&gt; WalkingAnimal &lt;$&gt; decode &lt;*&gt; decode
      -- this is new...
      (2, 2) -&gt; SwimmingAnimal &lt;$&gt; decode
      _      -&gt; fail &quot;invalid Animal encoding&quot;</pre><h3>Adding/removing/modifying fields</h3><p>Say then we want to add a new field to our <code>WalkingAnimal</code> constructor,</p><pre>data Animal = HoppingAnimal { animalName :: String, hoppingHeight :: Int }
            | WalkingAnimal { animalName :: String, walkingSpeed :: Int, numberOfFeet :: Int }
            | SwimmingAnimal { numberOfFins :: Int }
            deriving (Generic)</pre><p>We can account for this by representing <code>WalkingAnimal</code> with a new encoding with
a new tag,</p><pre>encodeAnimal :: Animal -&gt; Encoding
-- HoppingAnimal, SwimmingAnimal cases are unchanged...
encodeAnimal (HoppingAnimal name height) =
    encodeListLen 3 &lt;&gt; encodeWord 0 &lt;&gt; encode name &lt;&gt; encode height
encodeAnimal (SwimmingAnimal numberOfFins) =
    encodeListLen 2 &lt;&gt; encodeWord 2 &lt;&gt; encode numberOfFins
-- This is new...
encodeAnimal (WalkingAnimal animalName walkingSpeed numberOfFeet) =
    encodeListLen 4 &lt;&gt; encodeWord 3 &lt;&gt; encode animalName &lt;&gt; encode walkingSpeed &lt;&gt; encode numberOfFeet

decodeAnimal :: Decoder s Animal
decodeAnimal = do
    len &lt;- decodeListLen
    tag &lt;- decodeWord
    case (len, tag) of
      -- these cases are unchanged...
      (3, 0) -&gt; HoppingAnimal &lt;$&gt; decode &lt;*&gt; decode
      (2, 2) -&gt; SwimmingAnimal &lt;$&gt; decode
      -- this is new...
      (3, 1) -&gt; WalkingAnimal &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; pure 4
                                                     -- ^ note the default for backwards compat
      (4, 3) -&gt; WalkingAnimal &lt;$&gt; decode &lt;*&gt; decode &lt;*&gt; decode
      _      -&gt; fail &quot;invalid Animal encoding&quot;</pre><p>We can use this same approach to handle field removal and type changes.</p></div><a href="#g:7" id="g:7"><h1>Working with foreign encodings</h1></a><div class="doc"><p>While <code>cborg</code> is primarily designed to be a Haskell serialisation
 library, the fact that it uses the standard CBOR encoding means that it can also
 find uses in interacting with foreign non-<code>cborg</code> producers and
 consumers. In this section we will describe a few features of the library
 which may be useful in such applications.</p></div><a href="#g:8" id="g:8"><h2>Working with arbitrary terms</h2></a><div class="doc"><p>When working with foreign encodings, it can sometimes be useful to capture a
serialised CBOR term verbatim (for instance, so you can later re-serialise it in
some later result). The <code><a href="../cborg-0.2.6.0/Codec-CBOR-Term.html#v:Term" title="Codec.CBOR.Term">Term</a></code> type provides such a
representation, losslessly capturing a CBOR AST. It can be serialised and
deserialised with its <code><a href="Codec-Serialise-Class.html#t:Serialise" title="Codec.Serialise.Class">Serialise</a></code> instance.</p></div><a href="#g:9" id="g:9"><h2>Examining encodings</h2></a><div class="doc"><p>We can also look In addition to serialisation and deserialisation, <code>cborg</code>
provides a variety of tools for representing arbitrary CBOR encodings in the
<a href="../cborg-0.2.6.0/Codec-CBOR-FlatTerm.html">Codec.CBOR.FlatTerm</a> and <a href="../cborg-0.2.6.0/Codec-CBOR-Pretty.html">Codec.CBOR.Pretty</a> modules.</p><p>The <code><a href="../cborg-0.2.6.0/Codec-CBOR-FlatTerm.html#v:FlatTerm" title="Codec.CBOR.FlatTerm">FlatTerm</a></code> type represents a single CBOR <em>term</em>, as
would be found in the ultimate CBOR representation. For instance, we can easily
look at the structure of our <code>Animal</code> encoding above,</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>toFlatTerm $ encode $ HoppingAnimal &quot;Fred&quot; 42
</code></strong>[TkListLen 3,TkInt 0,TkString &quot;Fred&quot;,TkInt 42]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fromFlatTerm (decode @Animal) $ toFlatTerm $ encode (HoppingAnimal &quot;Fred&quot; 42)
</code></strong>Right (HoppingAnimal {animalName = &quot;Fred&quot;, hoppingHeight = 42})
</pre><p>This can be useful both for understanding external CBOR formats, as well as
understanding and testing your own hand-rolled encodings.</p><p>The package also includes a pretty-printer in <a href="../cborg-0.2.6.0/Codec-CBOR-Pretty.html">Codec.CBOR.Pretty</a>, for
visualising the CBOR wire protocol alongside its semantic structure. For instance,</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>putStrLn $ Codec.CBOR.Pretty.prettyHexEnc $ encode $ HoppingAnimal &quot;Fred&quot; 42
</code></strong>83  # list(3)
   00  # word(0)
   64 46 72 65 64  # text(&quot;Fred&quot;)
   18 2a  # int(42)
</pre></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.2</p></div></body></html>