# Лабораторная работа № 2

---

## Ручное построение нисходящих парсеров

### 1. Разработка грамматики

 В данном разделе разработаем грамматику для лямбда выражений в питоне. Они обычно принимают вид, похожий на следующее
 
```python
lambda x, y, z : x + y * z
```

То есть терминал лямбда, далее ненулевое количество переменных, двоеточие (терминал) 
и какое то выражение, я реализовал случай арифметических выражений с переменными

Можно попробовать составить грамматику следующим образом:

```
CFG for lambda expressions in python:

S -> lambda P : E
P -> id | id, P
E -> E + T | E - T | T
T -> T * F | T / F | F
F -> const | id | ( E )
```

Заглавные буквы - нетерминалы, последовательность маленьких
символов - терминалы. То есть, например, `lambda` - терминал, `+` терминал, а
`S` - нетерминал

Разберемся, что здесь происходит. `S` - стартовый нетерминал, он может 
преобразоваться только в `lambda P : E`. `P` - нетерминал для выражений переменных
у нас может быть одна переменная так и много, поэтому у нас два правила `P -> id | id, P`.
Важно, что если у нас много переменных, то между ними нужно расставить запятые.
`E` - обычное выражение, в грамматике присутствуют `T` и `F`, они нужны для того, чтобы
в нашей грамматике была приоритетность. `F` может преобразовать либо в какую-то числовую константу, либо в переменные,
либо в еще одно выражение, но уже в скобочках.

Можно заметить, что данная грамматика содержит левую рекурсию, чтобы уметь
строить нисходящий разбор, нам нужно привести ее в LL(1) грамматику путем отстранения
левой рекурсии

```
CFG for lambda expressions in python #2 :

S  -> lambda P : E
P  -> id P'
P' -> , id P' | eps
E  -> T E'
E' -> + T E' | - T E' | eps
T  -> F T'
T' -> * F T' | / F T' | eps
F  -> const | id | ( E )

CFG for lambda expressions in python #3 
(modification)

S  -> lambda P : E
P  -> id P'
P' -> , id P' | eps
E  -> T E'
E' -> + T E' | - T E' | eps
T  -> F T'
T' -> * F T' | / F T' | eps
F  -> const | id | ( E ) | ( S ) ( P ) 

// but now in the last set of rules, the second and
third rule have a common prefix, we need to eliminate it

# 4

S  -> lambda P : E
P  -> id P'
P' -> , id P' | eps
E  -> T E'
E' -> + T E' | - T E' | eps
T  -> F T'
T' -> * F T' | / F T' | eps
F  -> const | id | ( F'
F' -> E ) | S ) ( P ) 
```

### 2. Построение лексического анализатора

В нашей грамматике следующие терминальные символы: `lambda`, `id`, `,`, 
`+`, `-`, `*`, `/`, `const`, `(`, `)`, и конец строки.

Они все лежат в `enum class TokenId`. Но, некоторые терминалы, 
например, `const` и `id` могут держать внутри дополнительную информацию,
в случае `const` это может быть какое-то число, в случае `id` - название
переменной, например, `x` или `y`. Поэтому, для красоты я завел класс `Token`
который, по своей сути обертка над `TokenId` и от него унаследовался много раз
:

```kotlin
enum class TokenId {
    LPAREN, RPAREN, LAMBDA, COLON, COMMA,
    PLUS, MINUS, TIMES, DIVIDE, ID, CONST, END
}

sealed class Token(val tag: TokenId) 

class Constant(private val value: Int) : Token(TokenId.CONST)
```
### 3. Построение синтаксического анализатора

Построим множества `first` и `follow` для нашей грамматики

| nonterminal |        first        |            follow            |
|:------------|:-------------------:|:----------------------------:|
| **S**       |     {`lambda`}      |            {`$`}             |
| **P**       |       {`id`}        |            {`:`}             |
| **P'**      |     {`,`,`eps`}     |            {`:`}             |
| **E**       | {`(`, `id`,`const`} |          {`$`, `)`}          |
| **E'**      | { `+`, `-`, `eps` } |          {`$`, `)`}          |
| **T**       | {`(`, `id`,`const`} |      {`+`,`-`,`$`, `)`}      |
| **T'**      |  {`*`, `/`,`eps`}   |      {`+`,`-`,`$`, `)`}      |
| **F**       | {`(`, `id`,`const`} | {`*`,`/`,`+`, `-`, `$`, `)`} |


Сам разбор находится в файле `ParserHelper.kt`, `Parser.kt` всего лишь обертка над ним
и была сделана для улучшения апи. 

### 4. Визуализация дерева разбора

Для того чтобы посмотреть на работу программы, достаточно запустить скрипт `run.sh`,
который лежит в корне проекта. Запустив скрипт, он вас попросит ввести произвольное 
лямбда выражение. Программа определит - принадлежит ли введенная строка грамматике, и если
принадлежит - сгенерирует дерево разбора в png формате.

Вот пример работы программы на какой-то лямбде. Стоит отметить, что терминалы
обведены красным (кроме `eps`). Это сделано для того, чтобы улучшить видимость нашей строки в дереве
разбора

![image](out/output.png)

### 5. Тестирование

Тесты к парсеру лежат по пути `src/test/kotlin`. Чтобы их запустить достаточно запустить
заготовленный скрипт `run-tests.sh`

